/* "MT.c" -- create translation tables for Windows 3.00 keyboard drivers.
**
** This takes the binary '.WK2' files for Olivetti Windows 2.03 keyboard
** translation tables as its input, and creates a symbolic MASM source
** file containing a translation table for the type 4 (Enhanced) keyboard,
** as well as patches for other types (1..6).
**
** The file "tem.tem" is read, to provide parts of the output text
** which are not generated by this program.
**
************************************************************************ 
**  History
** 19 sep 88	peterbe		No longer write flags twice.
** 25 aug 88	peterbe		Put CountryName before main trans. table.
** 23 aug 88	peterbe		Added UMLAUT2.
** 16 aug 88	peterbe		Special handling for Nokia 6 VK_OEM_102
**				in scanlist[] handling.  Added entries for
**				scancodes 87, 88 in scanlist[], for Enhanced.
** 14 aug 88	peterbe		Added GetRTFlags(), GetCountry().
** 10 aug 88	peterbe		Added IsMorto(), WriteCtlAlt(), WriteCapital(),
**				WriteVKPatch(), InitMorto(), WriteMorto().
** 09 aug 88	peterbe		Added code for copying text from TEM.TEM.
**				Wrote routines for AsciiTab and Control table
**				generation.
** 08 aug 88	peterbe		Created on the basis of Windows 2.03
**				program 'Kdiff.c'.
********************************************************************* */

#include <stdio.h>
#include <string.h>


/* include values of virtual keys */
#include "vkoem.h"
#include "vkwin.h"

#define BYTE unsigned char
#define WORD unsigned int
#define BOOL unsigned int
#define FALSE 0
#define TRUE 1

/* *****************************************************************
**
** The following defines the buffers containing 6 keyboard translation
** files for Windows 2.03.
**
***************************************************************** */
union kbtab
    {
    BYTE b[1500];		/* byte image of whole file */

    struct
	{
	/* BYTE entries in header */
	BYTE	key[9];		/* should be "OLIKB2.xx" */
	BYTE	TableType;	/* 9 */
	BYTE	KeyType;	/* A */
	BYTE	IsOli;		/* C */
	BYTE	IsEri;		/* B */
	BYTE	fKbRt;		/* D */
	BYTE	OliType;	/* E */
	BYTE	PCType;		/* F */
	BYTE	PCTypeHigh;	/* 10 */
	BYTE	RTFlags;	/* 11 */

	/* the following group of pointers should be the same in
	** every table
	*/
	/* WORD	OAnsiToOem; */	/* offset of AnsiToOem table */
	/* WORD	OOemToAnsi; */	/* offset of OemToAnsi table */
	
	WORD	KeyTransBase;	/* offset of */
	WORD	KeyTransTblSize; /* length of keyTranslationTable */

	WORD	keyNumBase;	/* start of KeyNumTrans[]--contents fixed */

	WORD	AsciiTabBase;	/* Start of AsciiTable */
	WORD	VirtualDefault;	/* End of AsciiTable */

	/* the sizes and offsets starting with [CapitalTabBase] will vary
	** from table to table.
	*/
	WORD	DeadKeyBase;	/* start of DeadKeyTable */
	WORD	DeadKeyDefault;	/* end of DeadKeyTable */

	WORD	CapitalTabBase;	/* start of CapitalTable */
	WORD	CapitalDefault;	/* end of CapitalTable */

	WORD	CtrlAltBase;	/* start of CtrlAltTable */
	WORD	CtrlAltDefault;	/* end of CtrlAltTable */

	WORD	MortoBase;	/* start of TavoloMorto */

	WORD	KeyTabEnd;	/* Pointer to byte after end of file */

	WORD	pCountryName;	/* Pointer to country name string */

	} h;

    };

union kbtab buff1, buff2, buff3, buff4, buff5, buff6, buff7;

union kbtab * tabbufs[] = {
	& buff1,
	& buff2,
	& buff3,
	& buff4,
	& buff5,
	& buff6,
	& buff7
	};

/* define structure for AsciiTab[] */
struct AscTab {
	BYTE	vcode;
	BYTE	unshifted;
	BYTE	shifted;
	BYTE	control;
	};

/* *****************************************************************
**	Other data
***************************************************************** */

/* filename pointers and FILE pointers */
BYTE * fname1;
BYTE * fname2;
BYTE * fname3;
BYTE * fname4;
BYTE * fname5;
BYTE * fname6;
BYTE * fname7;
BYTE * oname;

FILE *fopen(), *file1, *file2, *file3, *file4, *file5, *file6, *file7,
	*temfile, *ofile;

WORD size1, size2, size3, size4,	/* byte size of each file */
     size5, size6, size7;

WORD file3is;				/* is 0 (file 3 is unique) or
					** 1 (file3 is file1) or 2..*/


char sCountry[21];			/* country name */

int mapvk[] = {1,3,2,4,5,6};		/* order in which patches to
					** keyTrTab() occur */

int mapasc[] = {1,3,2,5,6};		/* order in which patches to
					** Ascii translation tables
					** occur (no entry for '4') */

char tembuf[160];			/* buffer for copying TEM.TEM */

/* Scan codes to be included in the virtual keycode patch tables */

BYTE scanlist[] = {
	12,13,16,17,21,26,27,30,39,40,
	41,43,44,50,51,52,53,
	86,		/* 98 for Nokia type 6 VK_OEM_102: See TEM.TEM file */
	87,88		/* VK_F11, VK_F12 on enhanced keyboard */
	};


#define SZVK sizeof scanlist

/* Virtual keycode patch tables */

BYTE vklists[6][SZVK+1];

/* VK's to be processed for Ascii table */

BYTE asclist[] = {
	VK_0, VK_1, VK_2, VK_3, VK_4, VK_5, VK_6, VK_7, VK_8, VK_9,
	VK_OEM_COMMA, VK_OEM_PERIOD, VK_OEM_MINUS, VK_OEM_PLUS,
	VK_OEM_1, VK_OEM_2, VK_OEM_3, VK_OEM_4,
	VK_OEM_5, VK_OEM_6, VK_OEM_7, VK_OEM_8,
	VK_OEM_102, VK_DECIMAL, 0 };

/* VK's NOT to be processed for Control table */

BYTE ctllist[] = {
    VK_CANCEL, VK_BACK, VK_RETURN, VK_ESCAPE, VK_SPACE, VK_EXECUTE
    };

/* maximum number of patches for each type */

int MaxMorto = 0;
int MaxCtl = 0;
int MaxCtlAlt = 0;
int MaxShCtlAlt = 0;
int MaxCapital = 0;

/* Number of entries for type 4 keyboard in Morto, Ctrl, etc. tables.
** If a corresponding value in the preceding list is bigger, it is
** necessary to put padding at the end of the type 4 tables. */

int ExtMorto = 0;
int ExtCtl = 0;
int ExtCtlAlt = 0;
int ExtShCtlAlt = 0;
int ExtCapital = 0;


/* *****************************************************************
** define shift state bits used in old 2.03 dead key tables.
** (the old names are based on Olivetti keyboard tables)
** In the old deadkey tables, a shift byte may have bits set
** for more than one shift state.  The bit values used were
** determined by the internal operation of the old driver.
***************************************************************** */

    /* Name used here	Name in 2.03 'olikbd.inc' file */

#define SHIFT0 1	/* shift_1 = no shift */
#define SHIFT1 2	/* shift_2 = shift */
#define SHIFT2 0x10	/* shift_6 = control */
#define SHIFT3 0x20	/* shift_8 = shift-control (never used) */
#define SHIFT4 4	/* shift_4 = alt only !! */
#define SHIFT5 8	/* shift_3 = shift-alt !! */
#define SHIFT6 0x40	/* shift_5 = control-alt */
#define SHIFT7 0x80	/* shift_7 = control-alt */


/* *****************************************************************
** This maps the shift state numbers used in the new 3.00 driver to
** mask bits used in the dead key tables in the old 2.03 driver.
***************************************************************** */

BYTE shiftmasks[] = {
    SHIFT0, SHIFT1, SHIFT2, 0,
    0, 0, SHIFT4+SHIFT6, SHIFT6+SHIFT7
    };

/* *****************************************************************
**	names of virtual keys
***************************************************************** */

char * vknames[] = {
#include "vknames.h"
#include "vkonames.h"
	};

/* *****************************************************************
**	Definitions and variables for handling dead keys
***************************************************************** */

/* define ANSI codes for accents. Umlaut and acute varies. */

#define ACUTE 0xb4
#define ACUTE1 0x27

/* Umlaut dead char. may be double quote, double dot, or raised dot */
#define UMLAUT 0x22
#define UMLAUT1 0xa8
#define UMLAUT2 0xb7

#define GRAVE 0x60
#define CIRCUMFLEX 0x5e
#define TILDE 0x7e
#define CEDILLA 0xb8

/* flags indicating existence of dead keys in old tables:
** initialized in InitMorto() */

int hasacute = 0;
int hasgrave = 0;
int hasumlaut = 0;
int hascircumflex = 0;
int hastilde = 0;
int hascedilla = 0;

/* value of acute and umlaut dead keys. Initialized in InitMorto() */

int acute = ACUTE;
int umlaut = UMLAUT;

/* *****************************************************************
* * forward declarations
***************************************************************** */

char * GetCountry(char *, int);




/* *****************************************************************
********************* The main program ***************************** 
***************************************************************** */

main(argc, argv)
int	argc;
BYTE	*argv[];
{
    int i;
    int j;
    int k;

    /* handle the arguments */

    if ((argc < 6) || (argc > 9))
	{
	printf(".. wrong number of arguments\n");
	badUsage(1);
	}

    fname1 = argv[1];
    fname2 = argv[2];
    fname3 = argv[3];
    fname4 = argv[4];
    switch(argc)
	{
	case 6:
	    oname = argv[5];
	    break;
	case 7:
	    fname5 = argv[5];
	    oname = argv[6];
	    break;
	case 8:
	    fname5 = argv[5];
	    fname6 = argv[6];
	    oname = argv[7];
	    break;
	case 9:
	    fname5 = argv[5];
	    fname6 = argv[6];
	    fname7 = argv[7];
	    oname = argv[8];
	    break;
	}


    /* File 3 (for 86-key keyboards) may be the same as 1 or 2,
    ** so check if it is.
    **/

    if (0 == strcmp(fname3, fname1))
	file3is = 1;
    else if (0 == strcmp(fname3, fname2))
	file3is = 2;
    else
	file3is = FALSE;

    /* Open the output file */

    if ((ofile = fopen(oname, "w")) == NULL) {
	printf("mt: can't open output file <%s>\n",
		oname);
	badUsage(6);
	}

    /* Open the input files */

    fprintf (ofile, "; '%s' Windows 2.03 keyboard table file based on:\n",
	oname);

    fprintf (ofile, ";  '%s', '%s', '%s', '%s'",
	fname1, fname2, fname3, fname4);

    if (argc > 6)
	fprintf (ofile, ", '%s'", fname5);
    if (argc > 7)
	fprintf (ofile, ", '%s'", fname6);
    if (argc > 8)
	fprintf (ofile, ", '%s'", fname7);

    fprintf (ofile, "\n\n");

    if ((file1 = fopen(fname1, "rb")) == NULL) {
	printf("mt: can't open input file <%s>\n",
		fname1);
	badUsage(2);
	}

    if ((file2 = fopen(fname2, "rb")) == NULL) {
	printf("mt: can't open input file <%s>\n",
		fname2);
	badUsage(3);
	}

    if (file3is)
      fprintf(ofile,
	"; Table 3 (for 'AT' 84 or 86-key keyboards) is the same as table %d\n",
		file3is);
    else
	{
	if ((file3 = fopen(fname3, "rb")) == NULL)
	    {
	    printf("mt: can't open input file <%s>\n",
		fname3);
	    badUsage(4);
	    }
	}

    if ((file4 = fopen(fname4, "rb")) == NULL)
	{
	printf("mt: can't open input file <%s>\n",
		fname4);
	badUsage(5);
	}

    if (argc > 6)
	{

	if ((file5 = fopen(fname5, "rb")) == NULL)
	    {
	    printf("mt: can't open input file <%s>\n",
		fname5);
	    badUsage(6);
	    }
	if (argc > 7)
	    { 

	    if ((file6 = fopen(fname6, "rb")) == NULL)
		{
		printf("mt: can't open input file <%s>\n",
		    fname6);
		badUsage(7);
	        }
	    if (argc > 8)
		{

		if ((file7 = fopen(fname7, "rb")) == NULL)
		    {
		    printf("mt: can't open input file <%s>\n",
			fname7);
		    badUsage(8);
	            }

		} /* > 8 */

	    } /* > 7 */

        } /* > 6 */

    if ((temfile = fopen("tem.tem", "r")) == NULL)
	{
	printf("mt: can't open template file TEM.TEM\n");
	badUsage(9);
	}


    /* read the files into the buffers */
    size1 = fread((char *) buff1.b, 1, sizeof(union kbtab), file1);
    size2 = fread((char *) buff2.b, 1, sizeof(union kbtab), file2);
    size3 = (file3is) ? 0 :
	    fread((char *) buff3.b, 1, sizeof(union kbtab), file3);
    size4 = fread((char *) buff4.b, 1, sizeof(union kbtab), file4);
    if (argc > 6)
	size5 = fread((char *) buff5.b, 1, sizeof(union kbtab), file5);
    if (argc > 7)
	size6 = fread((char *) buff6.b, 1, sizeof(union kbtab), file6);
    if (argc > 8)
	size7 = fread((char *) buff7.b, 1, sizeof(union kbtab), file7);

    if (file3is)
	buff3.h.KeyTabEnd = 0;
	
    /* Binary files are all read into memory, so close them. */

    fclose(file1);
    fclose(file2);
    fclose(file3);
    fclose(file4);
    if (argc > 6)
	fclose(file5);
    if (argc > 7)
	fclose(file6);
    if (argc > 8)
	fclose(file7);


    /* Now process the input files, merging output with text copied from
    ** "TEM.TEM".
    */

    /* Skip heading */
    SkipTem();
    CopyTem();

    /* Determine which dead-key accents are used in this country,
    ** and also what character codes are used for umlaut and acute. */

    InitMorto();


    /* write out equates which define which sections of the dead key
    table to put in. */

    fprintf(ofile, (hasgrave) ?
	"DGRAVE\t\tequ\t1\n" : "\t; No grave deadkeys\n");

    fprintf(ofile, (hasacute) ?
	"DACUTE\t\tequ\t1\n" : "\t; No acute deadkeys\n");

    fprintf(ofile, (hascircumflex) ?
	"DCIRCUMFLEX\tequ\t1\n" : "\t; No circumflex deadkeys\n");

    fprintf(ofile, (hasumlaut) ?
	"DUMLAUT\t\tequ\t1\n" : "\t; No umlaut deadkeys\n");

    fprintf(ofile, (hastilde) ?
	"DTILDE\t\tequ\t1\n" : "\t; No tilde deadkeys\n");

    fprintf(ofile, (hascedilla) ?
	"DCEDILLA\tequ\t1\n" : "\t; No cedilla deadkeys\n");

    CopyTem();



    /* Define whether XT and AT tables are the same */

    if (file3is)
	fprintf(ofile,"ATSAME\t\equ\t1\n");
    else
	fprintf(ofile,"; AT and XT keyboards are different.\n");
    CopyTem();

    /* Define Umlaut and Acute dead keys */

    fprintf(ofile, "umlaut\t\tequ\t0%xh\n", umlaut);	/* 0xa8 */
    fprintf(ofile, "acute\t\tequ\t0%xh\n", acute);	/* 0xb4 */

    CopyTem();

    /* output country name */

    fprintf(ofile, "%%out .. %s\n", oname);
    CopyTem();

    /* extract patches for keyTrTab[] from the buffers */

    GenVKPatches();

    /* output patches for keyTrTab[].  There is a label for EACH
    ** type of keyboard, 1..6.
    */

    for (i = 0; i < 6; i++)
	{
	j = mapvk[i];
	if (i < 5)
	    {
	    k = mapvk[i + 1];
	    if (0 == strcmp(vklists[j - 1], vklists[k - 1]))
		fprintf(ofile, "\t; Same as next");
	    else
		WriteVKPatch(j);
	    }
	else
	    WriteVKPatch(j);

	CopyTem();
	}

    /* Flags for keyboard type 4 */

#define kbAltGr 8
#define kbShiftLock 0x40

    j = GetRTFlags();

    /* no longer do this twice !! */

    fprintf(ofile, "\tdb\t0");
    if (j & kbAltGr)
	fprintf(ofile, " + kbAltGr");
    if (j & kbShiftLock)
	fprintf(ofile, " + kbShiftLock");
    fprintf(ofile, "\n");

    CopyTem();


    /* output patches for unshifted/shifted Ascii table.
    ** For this and the following patches, there is a label for
    ** each type of table, 1..6, EXCEPT for type 4.
    ** Again, type 3 may be the same as type 1.
    */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    /* fprintf(ofile, "\t; Patch AsciiTab[] for type %d\n", j); */
	    WriteAsc(j, 0);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}


    /* output patches for Control */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    WriteCtl(j);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}

    /* output patches for Control-Alt */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    fprintf(ofile, "; Patch Control-Alt table for type %d\n", j);
	    WriteCtlAlt(j, 0);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}

    /* output patches for Shift-Control-Alt */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    fprintf(ofile, "; Patch Shift-Control-Alt table for type %d\n", j);
	    WriteCtlAlt(j, 1);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}

    /* output patches for dead key table 'Morto' */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    WriteMorto(j);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}


    /* output patches for Capital Table */

    for (i = 0; i < 5; i++)
	{
	j = mapasc[i];

	if ((j != 3) || (!file3is))
	    {
	    WriteCapital(j);
	    }
	else
	    fprintf(ofile, "; (Same as XT)\n");

	CopyTem();
	}

    /* output country name */

    GetCountry(sCountry, 20);

    fprintf(ofile, "\tdb\t'%s'\n", sCountry);
    CopyTem();

    /* output main translation table, type 4 */

    fprintf(ofile, ";\tVariable entries in AscTab[]:\n");
    WriteAsc(4, 1);
    CopyTem();


    /* output Morto, type 4 */

    WriteMorto(4);
    CopyTem();

    if (MaxMorto > ExtMorto)
	{
	fprintf(ofile, "\t; Padding\n");
	for (i = 0; i < MaxMorto - ExtMorto; i++)
	    WriteDead(0, 0, 0);
	}
    else
	fprintf(ofile, "\t; No Padding Needed\n");

    CopyTem();

    /* output Control, type 4 */

    WriteCtl(4);
    CopyTem();

    if (MaxCtl > ExtCtl)
	{
	fprintf(ofile, "\t; Padding\n");
	for (i = 0; i < MaxCtl - ExtCtl; i++)
	    WriteKtrans(0, 0);
	}
    else
	fprintf(ofile, "\t; No Padding Needed\n");
    CopyTem();

    /* output Control-Alt, type 4 */

    fprintf(ofile, "; Control-Alt insertions for type 4 \n");
    WriteCtlAlt(4, 0);
    CopyTem();

    if (MaxCtlAlt > ExtCtlAlt)
	{
	fprintf(ofile, "\t; Padding\n");
	for (i = 0; i < MaxCtlAlt - ExtCtlAlt; i++)
	    WriteKtrans(0, 0);
	}
    else
	fprintf(ofile, "\t; No Padding Needed\n");
    CopyTem();

    /* output Shift-Control-Alt, type 4 */

    fprintf(ofile,"; Shift-Ctrl-Alt insertions for type 4 \n");
    WriteCtlAlt(4, 1);
    CopyTem();

    if (MaxShCtlAlt > ExtShCtlAlt)
	{
	fprintf(ofile, "\t; Padding\n");
	for (i = 0; i < MaxShCtlAlt - ExtShCtlAlt; i++)
	    WriteKtrans(0, 0);
	}
    else
	fprintf(ofile, "\t; No Padding Needed\n");
    CopyTem();

    /* output Capital table, type 4 */

    WriteCapital(4);
    CopyTem();

    if (MaxCapital > ExtCapital)
	{
	fprintf(ofile,
		"\tdb\t%d dup (0)\t; Padding\n", MaxCapital - ExtCapital);
	}
    else
	fprintf(ofile, "\t; No Padding Needed\n");

    CopyTem();

    /* We're done processing the file! */

    fclose(temfile);

    fprintf(ofile, ";\n");
    fclose(ofile);

    printf("\nMT is done\n");

    exit(0);

} /* main() */


/* *****************************************************************
**	Tell if the string 'tembuf' begins with '.insert'.
***************************************************************** */

BOOL IsInsert()
{
char * p;

    p = tembuf + strspn(tembuf, " \t");		/* skip past blanks */
    return(0 == strnicmp(p,".INSERT", 7));

} /* IsInsert() */

/* *****************************************************************
**	Skip the next piece of the template file
***************************************************************** */

SkipTem()
{

    while(NULL != fgets(tembuf, 160, temfile))
	{
	if (IsInsert())
	    {
	    break;
	    }
	}

} /* SkipTem() */


/* *****************************************************************
**	Copy the next piece of the template file
***************************************************************** */

CopyTem()
{

    while(NULL != fgets(tembuf, 160, temfile))
	{
	if (IsInsert())
	    break;
	fprintf(ofile, "%s", tembuf);	/* this includes trailing EOL */
	}

} /* CopyTem() */


/* *****************************************************************
**	Write a byte to the output.
***************************************************************** */

WriteByte(n)
int n;
{
    n &= 0xff;

    if (n == 0xff)
	fprintf(ofile,"\t-1");			/* output as "-1" */
    else if ((n >= 0x7f) ||
	     (n < 32) ||
	     (n == '\''))
	fprintf(ofile,"\t0%xh", n);		/* output as hex */
    else
	fprintf(ofile,"\t'%c'", n);		/* output as Ascii in quotes */

} /* WriteByte() */



/* *****************************************************************
**	Write a byte to the output as a symbolic virtual keycode.
***************************************************************** */

WriteVk(n)
int n;
{

    fprintf(ofile,"%s", vknames[n & 0xff]);

} /* WriteVk() */



/* *****************************************************************
**
**	Write DB statement with 2 bytes + VK in comment, such as.
**
**	"	DB	';',	03fh	; VK_OEM_1
**
***************************************************************** */

WriteBBV(b1, b2, vk)
int b1;
int b2;
int vk;
{

    fprintf(ofile, "\tdb");
    WriteByte(b1);
    fprintf(ofile, ",");
    WriteByte(b2);
    fprintf(ofile, "\t; ");
    WriteVk(vk);
    fprintf(ofile, "\n");

} /* WriteBBV() */


/* *****************************************************************
**
**	Write 'ktrans' statement of the form
**
**	"	ktrans	VK_OEM_1,	9fh,	VKFLAG"
**
***************************************************************** */

WriteKtrans(vk, b)
int vk;
int b;
{

    fprintf(ofile, "\tktrans\t");
    WriteVk(vk);
    fprintf(ofile, ",");
    WriteByte(b);
    fprintf(ofile, ",\tVKFLAG\n");

} /* WriteKtrans() */

/* *****************************************************************
**
**	Write 'ktrans2' statement of the form
**
**	"	ktrans	VK_OEM_1,	9fh,	0abh,	VKFLAG"
**
***************************************************************** */

WriteKtrans2(vk, b1, b2)
int vk;
int b1;
int b2;
{
    fprintf(ofile, "\tktrans2\t");
    WriteVk(vk);
    fprintf(ofile, ",");
    WriteByte(b1);
    fprintf(ofile, ",");
    WriteByte(b2);
    fprintf(ofile, ",\tVKFLAG\n");

} /* WriteKtrans2() */



/* *****************************************************************
**
**	Write 'deadtrans' statement of the form
**
**	"	deadtrans	VK_OEM_1,	3,	acute,	VKFLAG"
**
**	The shift value is written in decimal.
**
***************************************************************** */

WriteDead(vk, shift, accent)
int vk;
int shift;
int accent;
{
    fprintf(ofile, "\tdeadtrans\t");
    WriteVk(vk);
    fprintf(ofile, ",\t%d", shift);
    fprintf(ofile, ",");

    switch(accent) {

	case ACUTE:
	case ACUTE1:
		fprintf(ofile, "\tacute");
		break;
	case GRAVE:
		fprintf(ofile, "\tgrave");
		break;
	case CIRCUMFLEX:
		fprintf(ofile, "\tcircumflex");
		break;
	case TILDE:
		fprintf(ofile, "\ttilde");
		break;
	case CEDILLA:
		fprintf(ofile, "\tcedilla");
		break;
	case UMLAUT:
	case UMLAUT1:
	case UMLAUT2:
		fprintf(ofile, "\tumlaut");
		break;

	default:
		WriteByte(accent);
		
	}

    fprintf(ofile, ",\tVKFLAG\n");

} /* WriteDead() */


/* *****************************************************************
**	Write Ascii translation table for shifted and unshifted,
**	in either of 2 formats.
**
**	The virtual keycodes are obtained from the string 'asclist',
**	and the translations are obtained by searching in the
**	input buffers.
**
**	If a character is a dead key, it's changed to -1 in the
**	table.
***************************************************************** */

WriteAsc(ktype, format4)
int ktype;		/* keyboard type 1..6 */
int format4;		/* true if in format for main table, false if
			** for patch table */
{
    int i;
    int vk;
    int sz;
    int	b1, b2;
    struct AscTab * pAscTab0;
    struct AscTab * pAscTab;
    int beg;
    int count;
    int j;

    /* get byte index in buffer, and size, of AsciiTab[] */

    beg = tabbufs[ktype - 1] -> h.AsciiTabBase;
    count = ((tabbufs[ktype - 1] -> h.VirtualDefault) - beg) / 4; 

    /* compute pointer to AsciiTab[] from buffer address and byte index.
    ** Casts are important!
    */

    pAscTab0 = (struct AscTab *) ((char *) tabbufs[ktype - 1] + beg);

    sz = strlen(asclist);
    for (i = 0; i < sz; i++)
	{
	/* get virtual keycode from 'asclist' */
	vk = asclist[i];

	/* search in the appropriate buffer for translations */

	b1 = b2 = 0xff;

	for (j = 0, pAscTab = pAscTab0; j < count; j++, pAscTab++)
	    {
	    if (vk == (pAscTab->vcode))
		{
		b1 = pAscTab->unshifted;
		b2 = pAscTab->shifted;

		/* Change characters which are dead keys to -1 */
		if (IsMorto(vk, 0, ktype))
		    {
		    b1 = 0xff;
		    fprintf(ofile, "\t; Unshifted is dead key\n");
		    }
		if (IsMorto(vk, 1, ktype))
		    {
		    b2 = 0xff;
		    fprintf(ofile, "\t; Shifted is dead key\n");
		    }

		break;
		}
	    }

	/* print out the unshifted and shifted translations for this VK */
	if (format4)
	    WriteKtrans2(vk, b1, b2);
	else
	    WriteBBV(b1, b2, vk);
	}

} /* WriteAsc() */


/* *****************************************************************
**	Determine if a BYTE is in a 0-terminated BYTE array.
***************************************************************** */

int ChInList(ch, p)
BYTE ch;
BYTE * p;
{
register BYTE * q;

    for (q = p; *q != 0; q++)
	if (*q == ch)
	    return(1);

    return(0);

} /* ChInList() */


/* *****************************************************************
**	Write entries for Control table for some keyboard type.
**
**	For keyboard type 4, the number of entries is saved in
**	ExtCtl.  For other types, the maximum number of patch
**	entries is saved in MaxCtl.
**
**	Entries in the input table for virtual keys in the string
**	'ctllist' are excluded, since these are in the fixed part
**	of the table.
**
**	Entries whose Ascii translation is -1 or control-letter
**	are excluded.
**
***************************************************************** */

WriteCtl(ktype)
int ktype;		/* keyboard type 1..6 */
{
    int vk;
    int	byt;
    struct AscTab * pAscTab;
    int beg;
    int count;
    int j;
    int totalcount;

    /* get byte index in buffer, and size, of AsciiTab[] */

    beg = tabbufs[ktype - 1] -> h.AsciiTabBase;
    count = ((tabbufs[ktype - 1] -> h.VirtualDefault) - beg) / 4; 

    /* compute pointer to AsciiTab[] from buffer address and byte index.
    ** Casts are important!
    */

    pAscTab = (struct AscTab *) ((char *) tabbufs[ktype - 1] + beg);

    for (j = 0, totalcount = 0; j < count; j++, pAscTab++)
	{
	/* get virtual code and translation for this entry */
	vk = pAscTab->vcode;
	byt = pAscTab->control;

	/* exclude entries which are in ctllist, control-letter,
	** or marked as undefined. */
	if (	(!ChInList(vk, ctllist)) &&
		((byt & 0xff) != 0xff) &&
		((byt < 1) || (byt > 26))
		)
	    {
	    WriteKtrans(vk, byt);
	    totalcount++;
	    }
	}

    /* save size or max patch size for handling padding */

    if (ktype == 4)
	{
	ExtCtl = totalcount;
	}
    else
	{
	if (totalcount > MaxCtl)
	    MaxCtl = totalcount;
	}

} /* WriteCtl() */

/* *****************************************************************
*	Routine for writing Control-Alt and Shift-Control-Alt
*	table entries.
*
*	A parameter selects which it is.
***************************************************************** */

WriteCtlAlt(ktype, which)
int ktype;			/* keyboard type */
int which;			/* 0 if CtlAlt, 1 if ShCtlAlt */
{
    union kbtab * base;
    int beg;
    char * pCtlAlt;
    int vk;
    BYTE byt;
    int count;

    count = 0;

    if (which != 0)
	which = 1;

    base = tabbufs[ktype - 1];
    beg = base -> h.CtrlAltBase;
    pCtlAlt = ((BYTE *) base) + beg;

    while (0xff != (vk = 0xff & * pCtlAlt))
	{
	byt = *(pCtlAlt + which + 1);
	if (byt != 0xff)
	    {
	    if (IsMorto(vk, 6 + which, ktype))
		{
		fprintf(ofile, "\t; Dead key: %s\n", vknames[0xff & vk]);
		}
	    else
		{
		WriteKtrans(vk, byt);
		count++;
		}
	    }

	pCtlAlt += 3;
	}

    /* handle maximum values for padding patch tables. */

    switch (which + ((ktype == 4) ? 2 : 0))
	{
	/* Enhanced keyboard */
	case 2:				/* ctl-alt */
		ExtCtlAlt = count;
		break;
	case 3:				/* sh-ctl-alt */
		ExtShCtlAlt = count;
		break;

	/* all other keyboards */
	case 0:				/* ctl-alt */
		if (count > MaxCtlAlt)
		    MaxCtlAlt = count;
		break;
	case 1:
		if (count > MaxShCtlAlt)
		    MaxShCtlAlt = count;
		break;
	}

} /* WriteCtlAlt() */



/* *****************************************************************
*	Routine for writing Capital table.
***************************************************************** */

WriteCapital(ktype)
int ktype;			/* keyboard type */
{
    union kbtab * base;
    int beg;
    char * pCapital;
    int count;
    BYTE vk;

    count = 0;

    /* xxx */ fprintf(ofile, "; Capital table, type %d\n", ktype);

    base = tabbufs[ktype - 1];
    beg = base -> h.CapitalTabBase;
    pCapital = ((BYTE *) base) + beg;

    while (0xff != (vk = 0xff & * pCapital))
	{
	fprintf(ofile,"\tdb\t");
	WriteVk(vk);
	fprintf(ofile,"\n");
	count++;
	pCapital += 2;
	}

    if (ktype == 4)
	ExtCapital = count;
    else
	if (count > MaxCapital)
	    MaxCapital = count;

} /* WriteCapital() */



/* *****************************************************************
*	Routine for generating Virtual Keycode patch arrays.
*
*	All 6 patch tables are read together so the print
*	routine can optimize the output file size.
***************************************************************** */

GenVKPatches()
{
    int ktype;		/* keyboard type 1..6 */
    BYTE * pKeyTrans;
    int beg;
    int i;

    /*  printf("\nGenVkPatches()");*/ 

    for (ktype = 1; ktype <= 6; ktype++)
	{
	/* printf("\nktype = %d", ktype);*/ 

	if ((ktype == 3) && file3is)
	    {
	    for (i = 0; i < SZVK; i++)
		vklists[ktype-1][i] = vklists[0][i];
	    }
	else
	    {
	    /* get byte index in buffer of KeyTrTab[] */

	    beg = tabbufs[ktype - 1] -> h.KeyTransBase;

	    /* compute pointer to KeyTrTab[] from buffer address and
	    ** byte index.
	    */

	    pKeyTrans = ((BYTE *) tabbufs[ktype - 1] + beg);

	    /* extract virtual keycodes from KeyTrTab[], for scan codes
	    ** in scanlist[].
	    */
	    for (i = 0; i < SZVK; i++)
		    {
		    vklists[ktype-1][i] = pKeyTrans[scanlist[i]];
		    }

	    /* special case for Nokia type 6, to handle VK_OEM_102,
	    ** scan code 98. */

	    if (ktype == 6)
		vklists[5][SZVK-1] =  pKeyTrans[98];
	    }

	/* 0-terminate each row of vklists[] */
	vklists[ktype][SZVK] = 0;
	}

} /* GenVKPatches() */


/* *****************************************************************
*	Routine for writing out a virtual keycode patch array.
***************************************************************** */

WriteVKPatch(ktype)
int ktype;
{
    int i;
    int scan;

    for (i = 0; i < SZVK; i++)
	{
	scan = scanlist[i];
	fprintf(ofile,"\tdb\t");
	WriteVk(vklists[ktype - 1][i]);
	fprintf(ofile,"\t; 0%xh %d\n", scan, scan);
	}

} /* WriteVKPatch() */

/* *****************************************************************
*	Print entries for dead-key table 'Morto'.
***************************************************************** */

WriteMorto(ktype)
int ktype;
{
    union kbtab * base;
    int beg;
    char * pMorto;
    BYTE vk;
    BYTE shifts;
    BYTE accent;
    int shiftno;
    int count;

    count = 0;

    if ((ktype == 3) && (file3is))
	ktype = 1;

    /* get pointer to Morto table */
    base = tabbufs[ktype - 1];
    beg = base -> h.MortoBase;
    pMorto = ((BYTE *) base) + beg;

    while (0 != (vk = (0xff & *pMorto)))
	{
	shifts = *(pMorto + 1);
	accent = *(pMorto + 2);
	for (shiftno = 0; shiftno < 8; shiftno++)
	    {
	    if (shifts & shiftmasks[shiftno])
		{
		WriteDead(vk, shiftno, accent);
		count++;
		}
	    }
	pMorto += 3;
	}

    if (ktype == 4)
	ExtMorto = count;
    else
	{
	if (count > MaxMorto)
	    MaxMorto = count;
	}

} /* WriteMorto() */


/* *****************************************************************
*	Initialize some variables and flags for dead key
*	translation.
***************************************************************** */

InitMorto()
{
    int ktype;
    union kbtab * base;
    int beg;
    char * pMorto;
    BYTE shifts;
    BYTE accent;

    for (ktype = 1; ktype <= 6; ktype++)
	{
	if ((ktype == 3) && (file3is))
	    ktype++;

	base = tabbufs[ktype - 1];
	beg = base -> h.MortoBase;
	pMorto = ((BYTE *) base) + beg;

	while (0 != (0xff & *pMorto))
	    {
	    accent = *(pMorto + 2);
	    switch(accent)
		{
		case ACUTE:
		case ACUTE1:
			hasacute = 1;
			if (ktype == 4)
			    acute = accent;
			break;
		case UMLAUT:
		case UMLAUT1:
		case UMLAUT2:
			hasumlaut = 1;
			if (ktype == 4)
			    umlaut = accent;
			break;
		case GRAVE:
			hasgrave = 1;
			break;
		case CIRCUMFLEX:
			hascircumflex = 1;
			break;
		case TILDE:
			hastilde = 1;
			break;
		case CEDILLA:
			hascedilla = 1;
			break;
		}

	    pMorto += 3;
	    }

	}	/* for (ktype... */

} /* InitMorto() */


/* *****************************************************************
*	Determine if a combination of VK code and shift
*	is a dead key for this table type.
*
*	Returns 1 if this is a dead key.
***************************************************************** */

int IsMorto(vk, shiftno, ktype)
int vk;			/* virtual keycode */
int shiftno;		/* 0: unshifted, 1: shifted, 2: ctrl, 4: alt, etc. */
int ktype;		/* 1..6 ... 1: XT, 3: AT, etc. */
{
    union kbtab * base;
    int beg;
    char * pMorto;
    BYTE smask;
    int thisvk;

    /* compute address of TavoloMorto[] in buffer for this ktype */

    base = tabbufs[ktype - 1];
    beg = base -> h.MortoBase;
    pMorto = ((BYTE *) base) + beg;

    smask = shiftmasks[shiftno];

    /* search for match of virtual keycode and shift state */

    vk &= 0xff;

    while (0 != (thisvk = 0xff & *pMorto))
	{
	if ((vk == thisvk) && (smask & *(pMorto + 1)) )
	    return(1);	/* It's a dead key for this shift */

	pMorto += 3;
	}

    return(0);

} /* IsMorto() */


/* *****************************************************************
**	Get flags byte for type 4 keyboard.
***************************************************************** */

GetRTFlags()
{
    union kbtab * base;

    base = tabbufs[3];		/* buffer for file type 4 */

    return ( base -> h.RTFlags);

} /* GetRTFlags() */


/* *****************************************************************
**	Get Country string.
**	If the string contains a digit, the string is 0-terminated
**	there.
***************************************************************** */

char * GetCountry(s, n)
char * s;		/* string offset */
int n;			/* max no of characters in n */
{
    union kbtab * base;
    int beg;
    char * pCountry;
    int i;

    /* get address of country name string in buffer, type 4 */
    base = tabbufs[3];
    beg = base -> h.pCountryName;
    pCountry = ((BYTE *) base) + beg;

    /* copy string; terminate at any digit */

    strncpy(s, pCountry, n);
    for (i = 0; i < strlen(s); i ++)
	if (s[i] >= '0' && s[i] <= '9')
	    {
	    s[i] = 0;
	    break;
	    }

    return(s);

} /* GetCountry() */

/* *****************************************************************
**	error routine for reporting command-line error
***************************************************************** */

badUsage(exitNumber)
int	exitNumber;
{
printf("Usage:\n");
printf(
  "\tmt XX1.wk2 XX2.wk2 XX3.wk2 XX4.wk2 [XX5.wk2 [XX6.wk2]] kbdXX.asm\n");
exit(exitNumber);

} /* BadUsage() */

