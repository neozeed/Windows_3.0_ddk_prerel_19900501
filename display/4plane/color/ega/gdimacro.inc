;/*	GDIMACRO.INC - GDI macros

LMHLockCnt	equ	byte ptr 3

PtoLMH	macro r1,r2
ifnb <r2>
	mov	r1,[r2 - 2]
else
	mov	r1,[r1 - 2]
endif
endm

LMHtoP macro r1,r2		;; Local Movable Handle to pointer
ifnb <r2>
	mov	r1,[r2]
else
	mov	r1,[r1]
endif
endm

LMPsize macro r1,r2		;; Local Movable pointer size
	mov	r1,-4[r2]
endm


LockDataSegment macro
ifndef	    GDILockDataSeg
ExternNP    GDILockDataSeg
endif
	cCall	 GDILockDataSeg
endm


UnlockDataSegment macro
ifndef	    GDIUnlockDataSeg
ExternNP    GDIUnlockDataSeg
endif
	cCall	GDIUnlockDataSeg
endm

ifndef ?HELPER
ExternFP    farGDILockDataSeg
endif

farLockDataSegment macro
ifndef	    farGDILockDataSeg
ExternFP    farGDILockDataSeg
endif
; save commented out because GDILockDataSeg saves ax - [t-kens] July,1988
;	save	<ax>
	cCall	 <far ptr farGDILockDataSeg>
endm


ifndef ?HELPER
ExternFP    farGDIUnlockDataSeg
endif

farUnlockDataSegment macro
ifndef	    farGDIUnlockDataSeg
ExternFP    farGDIUnlockDataSeg
endif
; save commented out because GDIUnlockDataSeg saves ax - [t-kens] July,1988
;	save	<ax>
	cCall	<far ptr farGDIUnlockDataSeg>
endm


;	NOTE:	The lock/unlock macros are not going to check
;		for under/overflow.  Its highly unlikely that
;		it will occur, and if it does, we'll be hosed
;		anyway....


LLock	macro	r
	inc	LMHLockCnt[r]		;;Increment ref count
endm

LUnlock macro	r
	dec	LMHLockCnt[r]		;;Decrement reference count
endm




;	The jmpnext macro and associated symbols are used to generate
;	the fall-through chain and generate the labels required for
;	error checking.

??ji	=	0			;;Initial index value

jmpnext macro e
jn %??ji,%(??ji+1),e			;;Set next label
endm

jn macro i,j,e
.sall
??ji&i:
.xall
ifb <e> 				;;If not the end of the chain
	db	03dh			;;mov bx, next two bytes
errn$	??ji&j,+2			;;mext lable must be two bytes away
endif
??ji=j					;;increment counter
endm

ifdef DEBUG
ifndef ?HELPER
ExternFP ValidateHandle
endif
endif


Valid? macro Handle,LowLimit,UpLimit
ifdef DEBUG
	push	bx
	push	dx
mov	bx, LowLimit
	ifnb	<UpLimit>
mov	dx, UpLimit
	else
mov	dx, LowLimit
	endif
	Save	<ax>
	cCall	<far ptr ValidateHandle>,<Handle,bx,dx>
	pop	dx
	pop	bx
endif
	endm

GDIGLOBALLOCK macro Handle,segRegister,offsetRegister
.lall
ifndef	    GlobalLock
ExternFP    GlobalLock
endif
	cCall	<far ptr GlobalLock>,<Handle>
ifnb <segRegister>
	mov	segRegister,dx
endif
ifnb <offsetRegister>
	mov	offsetRegister,ax
endif
.sall
	endm


GDIGLOBALUNLOCK macro Handle
ifndef	    GlobalUnlock
ExternFP    GlobalUnlock
endif
	cCall	<far ptr GlobalUnlock>,<Handle>
	endm

GDIRequestSem macro
	endm

GDIClearSem macro
	endm


;	setlbl generates a macro which will declare labels public
;	if "debug" has been defined.  The symbol generated will
;	be of the form:
;
;	    filename_label
;
;	where
;
;	    filename is the parameter given to the setlbl macro,
;	    and label is the first parameter given to the lbl macro
;	    which is generated by setlbl.
;
;
;	lbl is the macro which will define the given label and
;	if "debug" is defined, declare it public.
;
;
;	    lbl foo,<opt1>,opt2
;
;	where
;
;	    foo     is the name of the label
;	    opt1    is an optional second parameter.  If present,
;		    it must be some combination of
;			proc, label, near, far, byte, word, dword
;	    opt2    is an optional third parameter which if present
;		    must be "public".  It forces the declaration of
;		    "foo" to be public.



setlbl macro filename
  lbl &macro n,opt1,opt2
    .sall
    ifnb <opt1>
      n opt1
      ifdef debug
	filename&&_&&n equ n
	public filename&&_&&n
      endif
    else
      n:
      ifdef debug
	filename&&_&&n:
	public filename&&_&&n
      endif
    endif
    ifnb <opt2>
    public n
    endif
    .xall
  &endm
endm


; lock the given handle.  return in DX:AX lp to the memory block
FASTGLOBALLOCK		macro	handle
	cCall	GlobalLock,<handle>
	endm

FASTGLOBALUNLOCK	macro	handle
	cCall	GlobalUnlock,<handle>
	endm

smov	macro	segreg1,segreg2
	push	segreg2
	pop	segreg1
	endm

jmps	macro	there
	jmp	short there
	endm

; structure to allow easy access to components of DWORD.

HILO	struc
lo	dw	?
hi	dw	?
HILO	ends

; structure to allow easy access to components of LP.

OFFSEL	struc
off	dw	?
sel	dw	?
OFFSEL	ends

	if	0
*/

/* lock/unlock the given handle.  */
#define	FASTGLOBALLOCK(hand) (GlobalLock(hand))
#define	FASTGLOBALUNLOCK(hand)	(GlobalUnlock(hand))

#define MAX(a,b)	((a)>(b)?(a):(b))
#define MIN(a,b)	((a)<=(b)?(a):(b))
#define ABS(x)		(((x) >= 0) ? (x) : (-(x)))
#define LBYTE(x)	((BYTE)((x)&0xFF))
#define HBYTE(y)	((BYTE)(((y)>>8)&0xFF))
#define LWORD(x)	((short)((x)&0xFFFF))
#define HWORD(y)	((short)(((y)>>16)&0xFFFF))
#define MAKELONG(h,l)  ((long)(((WORD)l)|(((long)h)<<16)))

#ifdef DEBUG
extern far PASCAL ValidateHandle(HANDLE, short, short);
#define Valid(Handle, Low, High)    ValidateHandle(Handle, Low, High)
#else
#define Valid(Handle, Low, High)
#endif

#define GDIGLOBALLOCK(x)	GlobalLock(x)
#define GDIGLOBALUNLOCK(x)	GlobalUnlock(x)
#define GDILOCKRESOURCE(x)	LockResource(x)
#define GDIENTERCRITSEC()
#define GDIEXITCRITSEC()
#define LockDataSegment()	GDILockDataSeg()
#define UnlockDataSegment()	GDIUnlockDataSeg()
#define farLockDataSegment()	farGDILockDataSeg()
#define farUnlockDataSegment()	farGDIUnlockDataSeg()
#define GDIRequestSem()
#define GDIClearSem()


/*
	endif

;*/
